# hardware-configuration  -  Configuration file for setting up hardware on dekstop
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{
  config,
  lib,
  pkgs,
  modulesPath,
  ...
}: {
  imports = [(modulesPath + "/installer/scan/not-detected.nix")];

  # use the latest Linux kernel
  boot = {
    kernelPackages = pkgs.linuxPackages_latest;
    #  kernelPackages = pkgs.linuxPackages_xanmod_latest;
    #  kernelPackages = pkgs.linuxPackages_zen;

    kernelParams = [
      "i915.force_probe=4680" # Force the i915 driver to load for the Intel Iris Xe Graphics
      "hibernate=no" # Disable hibernation
      "intel_iommu=on" # Enable IOMMU
      "iommu=pt" # set IOMMU to passthrough mode
      "acpi_backlight=vendor" # Fix backlight control
      "acpi_osi=Linux" # Fix backlight control
      "acpi_sleep=nonvs" # pecific kernel parameters to enable proper power
      "rd.udev.log_level=3" # Increase kernel log verbosity
      "systemd.show_status=false"
      "no_console_suspend" # Prevent consoles from being suspended
      "splash"
      "logo.nologo"
    ];

    initrd.availableKernelModules = [
      "xhci_pci" # USB 3.0 (eXtensible Host Controller Interface)
      "ehci_pci" # USB 2.0 (Enhanced Host Controller Interface)
      "rtsx_pci_sdmmc" # Realtek PCI-E SD/MMC Card Host Driver
      "ahci" # SATA devices on modern AHCI controllers
      "nvme" # NVMe drives (really fast SSDs)
      "usbhid" # USB Human Interface Devices
      "usb_storage" # Utilize USB Mass Storage (USB flash drives)
      "sd_mod" # SCSI, SATA, and PATA (IDE) devices
      "sdhci_pci" # Secure Digital Host Controller Interface (SD cards)
      "uas" # USB attached SCSI drives
      "virtio_blk" # Another Virtio module, enabling high-performance communication between the host and virtualized block devices (e.g., hard drives) in a virtualized environment.
      "virtio_pci" # Part of Virtio virtualization standard, it supports efficient communication between the host and virtual machines with PCI bus devices.
    ];

    initrd.kernelModules = [
      "cifs" #  implementation of the Server Message Block (SMB) protocol, is used to share file systems, printers, or serial ports over a network.
      "dm-snapshot" #  a read-only copy of the entire file system and all the files contained in the file system.
    ];

    kernelModules = [
      "kvm-intel" # KVM on Intel CPUs
      "coretemp" # Temperature monitoring on Intel CPUs
      "fuse" # userspace filesystem framework.
      "i2c-dev" # An acronym for the “Inter-IC” bus, a simple bus protocol which is widely used where low data rate communications suffice.
      "i2c-piix4"
    ];
    extraModulePackages = [
      config.boot.kernelPackages.openrazer
    ];

    supportedFilesystems = ["ntfs" "ntfs3"];

    # consoleLogLevel = 3;
    # initrd = {
    #     verbose = false;
    #     systemd.enable = true; # uncomment to use initrd postDeviceCommands (e.g. to mount encrypted partitions)
    # };
    # plymouth = {
    #   enable = true; # Enable Plymouth boot screen for a nice graphical boot experience
    #   theme = "breeze";
    # };
  };

  services.btrfs.autoScrub = {
    enable = true;
    interval = "weekly";
  };

  fileSystems."/mnt/sda1" = {
    device = "/dev/sda1";
    fsType = "ntfs"; # Specify the file system type
    options = ["defaults"]; # Mount options (rw,exec,auto,user,async)
  };

  fileSystems."/mnt/sda2" = {
    device = "/dev/sda2";
    fsType = "ntfs"; # Specify the file system type
    options = ["defaults"]; # Mount options
  };

  # Enabling samba file sharing over local network
  services.samba = {
    enable = true; # Dont forget to set a password for the user with smbpasswd -a ${user}
    shares = {
      sda1 = {
        "path" = "/mnt/sda1";
        "comment" = "Window";
        "browseable" = "yes";
        "read only" = "no";
        "guest ok" = "yes";
        "create mask" = "0644";
        "directory mask" = "0755";
      };
      sda2 = {
        "path" = "/mnt/sda2";
        "comment" = "Linux";
        "browseable" = "yes";
        "read only" = "no";
        "guest ok" = "yes";
        "create mask" = "0644";
        "directory mask" = "0755";
      };
    };
    openFirewall = true;
  };

  # services.plex = {
  #   enable = true;
  #   openFirewall = true;
  # };

  swapDevices = [];
  zramSwap = {
    enable = true;
    memoryPercent = 10;
    algorithm = "lz4";
  };

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  # networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp3s0.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp0s20f0u11u2.useDHCP = lib.mkDefault true;

  # PPPoE configuration for PPPoE connections.
  # networking.interfaces.enp4s0 = {
  #  useDHCP = false;
  #  ipv4.addresses = ["192.168.100.2/24"];
  #  ipv4.gateway = "192.168.100.1";
  #  preUp = "pppoe-start";
  #  postDown = "pppoe-stop";
  # };

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  powerManagement.cpuFreqGovernor = lib.mkOverride 1 "performance";
  hardware.cpu.intel.updateMicrocode = lib.mkForce config.hardware.enableRedistributableFirmware;
}
